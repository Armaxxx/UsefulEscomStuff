#include "tftp.h"

void aMinusculas(char *cadena, unsigned int longitudCadena)
{
  unsigned int i;
  for(i = 0; i < longitudCadena; i++)
    cadena[i] = tolower(cadena[i]);
}

void aMayusculas(char *cadena, unsigned int longitudCadena)
{
  unsigned int i;
  for(i = 0; i < longitudCadena; i++)
    cadena[i] = toupper(cadena[i]);
}

bool enviarTrama(unsigned char *trama, unsigned int longitudTrama, struct host *local, struct host *remoto, int bandera)
{
  bool flg = false;
  int n = sendto(local->descriptorSocket, trama, longitudTrama, bandera, (struct sockaddr *)&remoto->dispositivoRed, sizeof(struct sockaddr_in));
  if(n == -1)
    perror("sendto()");
  else
  {
    printf("Enviamos Trama: ");
    imprimirTrama(trama, n);
    flg = true;
  }
  return flg;
}

bool recibirTrama(unsigned char *trama, unsigned int longitudTrama, struct host *local, struct host *remoto, int bandera, int *res)
{
  bool flg = false;
  socklen_t sa_len = sizeof(struct sockaddr_in);
  *res = recvfrom(local->descriptorSocket, trama, longitudTrama, bandera, (struct sockaddr *)&remoto->dispositivoRed, &sa_len);
  printf("%s %d\n",inet_ntoa(remoto->dispositivoRed.sin_addr),ntohs(remoto->dispositivoRed.sin_port));
  if(*res == -1)
    perror("recvfrom()");
  else
  {
    printf("Recibimos Trama: ");
    imprimirTrama(trama, *res);
    flg = true;
  }
  return flg;
}

void imprimirTrama(unsigned char *trama, unsigned int longitudTrama)
{
  unsigned int i;
  printf("Bytes: %d",longitudTrama);
  for(i = 0; i < longitudTrama; i++)
	{
		if(i % 16 == 0)
			printf("\n");
		printf("%.2x",trama[i]);
	}
	printf("\n");
}

unsigned int formarTramaRQ(char *trama, struct host *local, unsigned int modoTransferencia, unsigned int codOp)
{
  unsigned int n = 0;
  char *msg;
  int cO = htons(codOp);
  if((codOp == RRQ || codOp == WRQ) && (modoTransferencia == OCTET || modoTransferencia == NETASCII))
  {
    memcpy(trama+n, &cO, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, local->nombreFichero, local->longitudNombreFichero*sizeof(char));
    n += local->longitudNombreFichero*sizeof(char);
    memset(trama+n, 0x00, sizeof(char));
    n += sizeof(char);
    if(modoTransferencia == OCTET)
      msg = MSG_OCTET;
    else if(modoTransferencia == NETASCII)
      msg = MSG_NETASCII;
    memcpy(trama+n, msg, strlen(msg)*sizeof(char));
    n += (unsigned int)(strlen(msg)*sizeof(char));
    memset(trama+n, 0x00, sizeof(char));
    n += sizeof(char);
  }
  return n;
}

unsigned int formarTramaDT(char *trama, char *datos, unsigned int longitudDatos, unsigned int numeroBloque)
{
  unsigned int n = 0;
  unsigned short int codOp = htons(DAT);
  if(numeroBloque >= 0)
  {
    memcpy(trama+n, &codOp, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, &numeroBloque, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, datos, longitudDatos*sizeof(char));
    n += longitudDatos*sizeof(char);
  }
  return n;
}

unsigned int formarTramaACK(char *trama, unsigned int numeroBloque)
{
  unsigned int n = 0;
  unsigned short int codOp = htons(ACK);
  if(numeroBloque >= 1)
  {
    memcpy(trama+n, &codOp, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, &numeroBloque, 2*sizeof(char));
    n += 2*sizeof(char);
  }
  return n;
}

unsigned int formarTramaERR(char *trama, unsigned int codigoError, char *mensajeError, unsigned int longitudMensaje)
{
  unsigned int n = 0;
  unsigned short int codOp = htons(ERR);
  if(codigoError >= ERR_NDEF && codigoError <= ERR_NUSR)
  {
    memcpy(trama+n, &codOp, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, &codigoError, 2*sizeof(char));
    n += 2*sizeof(char);
    memcpy(trama+n, mensajeError, longitudMensaje*sizeof(char));
    n += longitudMensaje*sizeof(char);
    memset(trama+n, 0x00, sizeof(char));
    n += sizeof(char);
  }
  return n;
}

bool interpretarTramaRQ(char *trama, unsigned int longitudTrama, unsigned int *codOp, struct host *local, struct host *remoto)
{
  bool flg = false;
  unsigned int n = 0, i, k;
  char *modTrans, *msg;
  void *tmp_ptr;
  int cO;
  memcpy(&cO, trama+n, 2*sizeof(char));
  cO = ntohs(cO);
  n += 2*sizeof(char);
  if((cO == RRQ || cO == WRQ) && longitudTrama > 4 && trama[longitudTrama-1] == '\0')
  {
    *codOp = cO;
    for(i = 2; i < longitudTrama-1; i++)
      if(trama[i] == '\0')
        break;
    if(i != longitudTrama-2)
    {
      tmp_ptr = (char *)calloc(i-2,sizeof(char));
      if(tmp_ptr == NULL)
      {
        printf("calloc() [ERROR]\n");
        exit(1);
      }
      remoto->nombreFichero = tmp_ptr;
      memcpy(remoto->nombreFichero, trama+n, (i-2)*sizeof(char));
      n += (i-2)*sizeof(char);
      remoto->longitudNombreFichero = (i-2);
      n++;
      tmp_ptr = (char *)calloc(i-1,sizeof(char));
      if(tmp_ptr == NULL)
      {
        printf("calloc() [ERROR]\n");
        exit(1);
      }
      modTrans = tmp_ptr;
      memcpy(modTrans, trama+n, (longitudTrama-(i+1))*sizeof(char));
      n += (longitudTrama-(i+1))*sizeof(char);
      aMinusculas(modTrans, strlen(modTrans));
      if(strcmp(modTrans, MSG_OCTET) == 0)
      {
        remoto->modoTransferencia = OCTET;
        flg = true;
      }
      else if(strcmp(modTrans, MSG_NETASCII) == 0)
      {
        remoto->modoTransferencia = NETASCII;
        flg = true;
      }
    }
  }
  else if(cO < RRQ || cO > ERR)
  {
    msg = MSG_ERR_ILL;
    k = formarTramaERR(trama, ERR_ILL, msg, strlen(msg));
    if(k > 0)
      enviarTrama(trama, k, local, remoto, MSG_DONTWAIT);
  }
  return flg;
}

bool interpretarTramaDT(char *trama, unsigned int longitudTrama, char *datos, unsigned int *longitudDatos, unsigned int *numeroBloque, struct host *local, struct host *remoto)
{
  bool flg = false;
  unsigned int n = 0, k;
  void *tmp_ptr;
  int cO;
  char *msg;
  memcpy(&cO, trama+n, 2*sizeof(char));
  cO = ntohs(cO);
  n += 2*sizeof(char);
  if(cO == DAT)
  {
    memcpy(numeroBloque, trama+n, 2*sizeof(char));
    n += 2*sizeof(char);
    *longitudDatos = (longitudTrama - n);
    tmp_ptr = (char *)calloc(*longitudDatos,sizeof(char));
    if(tmp_ptr == NULL)
    {
      printf("calloc() [ERROR]\n");
      exit(1);
    }
    datos = tmp_ptr;
    memcpy(datos, trama+n, *longitudDatos*sizeof(char));
    n += *longitudDatos*sizeof(char);
    flg = true;
  }
  else if(cO < RRQ || cO > ERR)
  {
    msg = MSG_ERR_ILL;
    k = formarTramaERR(trama, ERR_ILL, msg, strlen(msg));
    if(k > 0)
      enviarTrama(trama, k, local, remoto, MSG_DONTWAIT);
  }
  return flg;
}

bool interpretarTramaACK(char *trama, unsigned int longitudTrama, unsigned int *numeroBloque, struct host *local, struct host *remoto)
{
  bool flg = false;
  unsigned int n = 0, k;
  int numBloq;
  char *msg;
  int cO;
  memcpy(&cO, trama+n, 2*sizeof(char));
  cO = ntohs(cO);
  n += 2*sizeof(char);
  if(cO == ACK)
  {
    memcpy(&numBloq, trama+n, 2*sizeof(char));
    n += 2*sizeof(char);
    if(numBloq > 0)
    {
      *numeroBloque = numBloq;
      flg = true;
    }
    else
    {
      msg = MSG_ERR_UNKID;
      k = formarTramaERR(trama, ERR_UNKID, msg, strlen(msg));
      if(k > 0)
        enviarTrama(trama, k, local, remoto, MSG_DONTWAIT);
    }
  }
  else if(cO < RRQ || cO > ERR)
  {
    msg = MSG_ERR_ILL;
    k = formarTramaERR(trama, ERR_ILL, msg, strlen(msg));
    if(k > 0)
      enviarTrama(trama, k, local, remoto, MSG_DONTWAIT);
  }
  return flg;
}

bool interpretarTramaERR(char *trama, unsigned int longitudTrama, unsigned int *codigoError, char *mensajeError, unsigned int *longitudMensaje, struct host *local, struct host *remoto)
{
  bool flg = false;
  unsigned int n = 0, k;
  int cO, cE;
  char *msg;
  memcpy(&cO, trama+n, 2*sizeof(char));
  cO = ntohs(cO);
  n += 2*sizeof(char);
  if(cO == ERR && trama[longitudTrama-1] == '\0')
  {
    *codigoError = cO;
    memcpy(&cE, trama+n, 2*sizeof(char));
    n += 2*sizeof(char);
    if(cE >= ERR_NDEF && cE <= ERR_NUSR)
    {
      *longitudMensaje = (longitudTrama - 5);
      memcpy(mensajeError, trama+n, *longitudMensaje*sizeof(char));
      printf("%s\n",mensajeError);
      n += *longitudMensaje*sizeof(char);
      flg = true;
    }
  }
  else if(cO < RRQ || cO > ERR)
  {
    msg = MSG_ERR_ILL;
    k = formarTramaERR(trama, ERR_ILL, msg, strlen(msg));
    if(k > 0)
      enviarTrama(trama, k, local, remoto, MSG_DONTWAIT);
  }
  return flg;
}

void modoCliente(struct host *local, struct host *servidor, unsigned int codOp)
{
  char tramaLocal[MAX_BUFFER], tramaRemota[MAX_BUFFER], datos[LEN_DATA];
  unsigned int longitudTramaLocal = MAX_BUFFER, longitudTramaRemota = MAX_BUFFER, longitudDatos, numeroBloque, n, i;
  int res;
  memset(tramaLocal, 0x00, longitudTramaLocal*sizeof(char));
  memset(tramaRemota, 0x00, longitudTramaRemota*sizeof(char));
  printf("Ejecutando en modo Cliente.\n");
  n = formarTramaRQ(tramaLocal, local, OCTET, codOp);
  if(enviarTrama(tramaLocal, longitudTramaLocal, local, servidor, 0))
  {
    if(recibirTrama(tramaRemota, longitudTramaRemota, local, servidor, 0, &res))
    {
      if(interpretarTramaDT(tramaRemota, res, datos, &longitudDatos, &numeroBloque, local, servidor))
      {
        if(codOp == RRQ && numeroBloque == 1)
        {
          printf("Se acepto lectura de archivo %s, recibiendo paquete %d...\n",local->nombreFichero,numeroBloque);
        }
        else if(codOp == WRQ && numeroBloque == 0)
        {
          printf("Se acepto escritura de archivo %s, esperando paquete %d...\n",local->nombreFichero,numeroBloque+1);
        }
      }
    }
  }
}

void modoServidor(struct host *local)
{
char tramaLocal[MAX_BUFFER], tramaRemota[MAX_BUFFER], datos[LEN_DATA];
  unsigned int longitudTramaLocal = MAX_BUFFER, longitudTramaRemota = MAX_BUFFER, longitudDatos, numeroBloque, n, i, codOp;
  int res;
  struct host remoto;
  memset(tramaLocal, 0x00, longitudTramaLocal*sizeof(char));
  memset(tramaRemota, 0x00, longitudTramaRemota*sizeof(char));
  memset(&remoto, 0x00, sizeof(struct host));
  //n = formarTramaRQ(tramaLocal, local, OCTET, codOp);
  printf("Ejecutando en modo Servidor.\n");
  if(recibirTrama(tramaRemota, longitudTramaRemota, local, &remoto, 0, &res))
  {
    printf("Recibimos Trama: ");
    imprimirTrama(tramaRemota, res);
    if(interpretarTramaRQ(tramaRemota, res, &codOp, local, &remoto))
    {
      if(codOp == RRQ)
      {
        printf("Se recibio peticion lectura archivo %s\n",remoto.nombreFichero);
      }
      else if(codOp == WRQ)
      {
        printf("Se recibio peticion escritura archivo %s\n",remoto.nombreFichero);
      }
    }
  }
}

bool establecerPuntoComunicacion(struct host *d, int dominio, int tipo, int protocolo, int puerto)
{
  bool flg = false;
  d->dispositivoRed.sin_family = dominio;
  d->dispositivoRed.sin_addr.s_addr = INADDR_ANY;
  d->dispositivoRed.sin_port = htons(puerto);
  d->descriptorSocket = socket(dominio, tipo, protocolo);
  if(d->descriptorSocket == -1)
    perror("socket() [ERROR]");
  else
    if(bind(d->descriptorSocket, (struct sockaddr *)&d->dispositivoRed, sizeof(struct sockaddr_in)) < 0)
      perror("bind() [ERROR]");
    else
      flg = true;
  return flg;
}

bool validarArgumentos(int argc, char **argv)
{
  bool flg = false;
  unsigned int i;
  if(argc == 2)
  if(strcmp(argv[1], "-s") == 0)
    flg = true;
  if(argc == 6)
  {
    if(strcmp(argv[1], "-c") == 0)
    {
      if(strcmp(argv[2], "-r") == 0 || strcmp(argv[2], "-w") == 0)
      {
        if(strlen(argv[3]) <= 255)
          for(i = 0; i < strlen(argv[3]); i++)
            if(argv[3][i] == '/' || (argv[3][i] == '\\' && argv[3][i+1] == '0'))
              return flg;
        if(strcmp(argv[4], "-srv") == 0)
          if(inet_addr(argv[5]) != INADDR_NONE)
            flg = true;
      }
    }
  }
  return flg;
}
